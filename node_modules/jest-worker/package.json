{
  "_args": [
    [
      {
        "raw": "jest-worker@22.2.2",
        "scope": null,
        "escapedName": "jest-worker",
        "name": "jest-worker",
        "rawSpec": "22.2.2",
        "spec": "22.2.2",
        "type": "version"
      },
      "/home/yugam/Desktop/Workspace/Alma-Mater/node_modules/metro"
    ]
  ],
  "_from": "jest-worker@22.2.2",
  "_id": "jest-worker@22.2.2",
  "_inCache": true,
  "_location": "/jest-worker",
  "_nodeVersion": "8.9.1",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/jest-worker_22.2.2_1518193692981_0.36704386466582917"
  },
  "_npmUser": {
    "name": "mjesun",
    "email": "mjesun@hotmail.com"
  },
  "_npmVersion": "5.5.1",
  "_phantomChildren": {},
  "_requested": {
    "raw": "jest-worker@22.2.2",
    "scope": null,
    "escapedName": "jest-worker",
    "name": "jest-worker",
    "rawSpec": "22.2.2",
    "spec": "22.2.2",
    "type": "version"
  },
  "_requiredBy": [
    "/jest-haste-map",
    "/metro"
  ],
  "_resolved": "https://registry.npmjs.org/jest-worker/-/jest-worker-22.2.2.tgz",
  "_shasum": "c1f5dc39976884b81f68ec50cb8532b2cbab3390",
  "_shrinkwrap": null,
  "_spec": "jest-worker@22.2.2",
  "_where": "/home/yugam/Desktop/Workspace/Alma-Mater/node_modules/metro",
  "bugs": {
    "url": "https://github.com/facebook/jest/issues"
  },
  "dependencies": {
    "merge-stream": "^1.0.1"
  },
  "description": "Module for executing heavy tasks under forked processes in parallel, by providing a `Promise` based interface, minimum overhead, and bound workers.",
  "devDependencies": {},
  "directories": {},
  "dist": {
    "integrity": "sha512-ZylDXjrFNt/OP6cUxwJFWwDgazP7hRjtCQbocFHyiwov+04Wm1x5PYzMGNJT53s4nwr0oo9ocYTImS09xOlUnw==",
    "shasum": "c1f5dc39976884b81f68ec50cb8532b2cbab3390",
    "tarball": "https://registry.npmjs.org/jest-worker/-/jest-worker-22.2.2.tgz",
    "fileCount": 6,
    "unpackedSize": 26203
  },
  "homepage": "https://github.com/facebook/jest#readme",
  "license": "MIT",
  "main": "build/index.js",
  "maintainers": [
    {
      "name": "cpojer",
      "email": "christoph.pojer@gmail.com"
    },
    {
      "name": "mjesun",
      "email": "mjesun@hotmail.com"
    }
  ],
  "name": "jest-worker",
  "optionalDependencies": {},
  "readme": "# jest-worker\n\nModule for executing heavy tasks under forked processes in parallel, by\nproviding a `Promise` based interface, minimum overhead, and bound workers.\n\nThe module works by providing an absolute path of the module to be loaded in all\nforked processes. Files relative to a node module are also accepted. All methods\nare exposed on the parent process as promises, so they can be `await`'ed. Child\n(worker) methods can either be synchronous or asynchronous.\n\nThe module also implements support for bound workers. Binding a worker means\nthat, based on certain parameters, the same task will always be executed by the\nsame worker. The way bound workers work is by using the returned string of the\n`computeWorkerKey` method. If the string was used before for a task, the call\nwill be queued to the related worker that processed the task earlier; if not, it\nwill be executed by the first available worker, then sticked to the worker that\nexecuted it; so the next time it will be processed by the same worker. If you\nhave no preference on the worker executing the task, but you have defined a\n`computeWorkerKey` method because you want _some_ of the tasks to be sticked,\nyou can return `null` from it.\n\nThe list of exposed methods can be explicitly provided via the `exposedMethods`\noption. If it is not provided, it will be obtained by requiring the child module\ninto the main process, and analyzed via reflection. Check the \"minimal example\"\nsection for a valid one.\n\n## Install\n\n```sh\n$ yarn add jest-worker\n```\n\n## Example\n\nThis example covers the minimal usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const worker = new Worker(require.resolve('./worker'));\n  const result = await worker.hello('Alice'); // \"Hello, Alice\"\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function hello(param) {\n  return 'Hello, ' + param;\n}\n```\n\n## API\n\nThe only exposed method is a constructor (`Worker`) that is initialized by\npassing the worker path, plus an options object.\n\n### `workerPath: string` (required)\n\nNode module name or absolute path of the file to be loaded in the child\nprocesses. Use `require.resolve` to transform a relative path into an absolute\none.\n\n### `options: Object` (optional)\n\n#### `exposedMethods: $ReadOnlyArray<string>` (optional)\n\nList of method names that can be called on the child processes from the parent\nprocess. You cannot expose any method named like a public `Worker` method, or\nstarting with `_`. If you use method auto-discovery, then these methods will not\nbe exposed, even if they exist.\n\n#### `numWorkers: number` (optional)\n\nAmount of workers to spawn. Defaults to the number of CPUs minus 1.\n\n#### `maxRetries: number` (optional)\n\nMaximum amount of times that a dead child can be re-spawned, per call. Defaults\nto `3`, pass `Infinity` to allow endless retries.\n\n#### `forkOptions: Object` (optional)\n\nAllow customizing all options passed to `childProcess.fork`. By default, some\nvalues are set (`cwd`, `env` and `execArgv`), but you can override them and\ncustomize the rest. For a list of valid values, check\n[the Node documentation](https://nodejs.org/api/child_process.html#child_process_child_process_fork_modulepath_args_options).\n\n#### `computeWorkerKey: (method: string, ...args: Array<any>) => ?string` (optional)\n\nEvery time a method exposed via the API is called, `computeWorkerKey` is also\ncalled in order to bound the call to a worker. This is useful for workers that\nare able to cache the result or part of it. You bound calls to a worker by\nmaking `computeWorkerKey` return the same identifier for all different calls. If\nyou do not want to bind the call to any worker, return `null`.\n\nThe callback you provide is called with the method name, plus all the rest of\nthe arguments of the call. Thus, you have full control to decide what to return.\nCheck a practical example on bound workers under the \"bound worker usage\"\nsection.\n\nBy default, no process is bound to any worker.\n\n## Worker\n\nThe returned `Worker` instance has all the exposed methods, plus some additional\nones to interact with the workers itself:\n\n### `getStdout(): Readable`\n\nReturns a `ReadableStream` where the standard output of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `getStderr(): Readable`\n\nReturns a `ReadableStream` where the standard error of all workers is piped.\nNote that the `silent` option of the child workers must be set to `true` to make\nit work. This is the default set by `jest-worker`, but keep it in mind when\noverriding options through `forkOptions`.\n\n### `end()`\n\nFinishes the workers by killing all workers. No further calls can be done to the\n`Worker` instance.\n\n**Note:** Each worker has a unique id (index that starts with `1`) which is\navailable on `process.env.JEST_WORKER_ID`\n\n# More examples\n\n## Standard usage\n\nThis example covers the standard usage:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    exposedMethods: ['foo', 'bar', 'getWorkerId'],\n    numWorkers: 4,\n  });\n\n  console.log(await myWorker.foo('Alice')); // \"Hello from foo: Alice\"\n  console.log(await myWorker.bar('Bob')); // \"Hello from bar: Bob\"\n  console.log(await myWorker.getWorkerId()); // \"3\" -> this message has sent from the 3rd worker\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nexport function foo(param) {\n  return 'Hello from foo: ' + param;\n}\n\nexport function bar(param) {\n  return 'Hello from bar: ' + param;\n}\n\nexport function getWorkerId() {\n  return process.env.JEST_WORKER_ID;\n}\n```\n\n## Bound worker usage:\n\nThis example covers the usage with a `computeWorkerKey` method:\n\n### File `parent.js`\n\n```javascript\nimport Worker from 'jest-worker';\n\nasync function main() {\n  const myWorker = new Worker(require.resolve('./worker'), {\n    computeWorkerKey: (method, filename) => filename,\n  });\n\n  // Transform the given file, within the first available worker.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  // Wait a bit.\n  await sleep(10000);\n\n  // Transform the same file again. Will immediately return because the\n  // transformed file is cached in the worker, and `computeWorkerKey` ensures\n  // the same worker that processed the file the first time will process it now.\n  console.log(await myWorker.transform('/tmp/foo.js'));\n\n  myWorker.end();\n}\n\nmain();\n```\n\n### File `worker.js`\n\n```javascript\nimport babel from 'babel-core';\n\nconst cache = Object.create(null);\n\nexport function transform(filename) {\n  if (cache[filename]) {\n    return cache[filename];\n  }\n\n  // jest-worker can handle both immediate results and thenables. If a\n  // thenable is returned, it will be await'ed until it resolves.\n  return new Promise((resolve, reject) => {\n    babel.transformFile(filename, (err, result) => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve((cache[filename] = result));\n      }\n    });\n  });\n}\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/facebook/jest.git"
  },
  "version": "22.2.2"
}
